<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voltage Tuning Exercise - Development Version</title>
    
    <style>
        /* Modern Professional Styling */
        :root {
            --primary-color: #2c3e50;
            --secondary-color: #3498db;
            --accent-color: #e74c3c;
            --success-color: #27ae60;
            --warning-color: #f39c12;
            --background-color: #f8f9fa;
            --card-background: #ffffff;
            --text-color: #2c3e50;
            --text-muted: #6c757d;
            --border-color: #dee2e6;
            --shadow: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.075);
            --shadow-lg: 0 1rem 3rem rgba(0, 0, 0, 0.175);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 1rem;
        }

        .header {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            padding: 1.5rem 0;
            text-align: center;
            margin-bottom: 2rem;
            border-radius: 0.5rem;
            box-shadow: var(--shadow-lg);
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: 300;
            margin-bottom: 0.5rem;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .main-grid {
            display: grid;
            grid-template-areas: 
                "controls"
                "charts"
                "status";
            gap: 2rem;
        }

        @media (min-width: 1200px) {
            .main-grid {
                grid-template-columns: 300px 1fr;
                grid-template-areas: 
                    "controls charts"
                    "status charts";
            }
        }

        /* Control Panel */
        .control-panel {
            grid-area: controls;
            background: var(--card-background);
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            padding: 1.5rem;
            box-shadow: var(--shadow);
        }

        .control-group {
            margin-bottom: 2rem;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        .control-group h3 {
            color: var(--primary-color);
            margin-bottom: 1rem;
            font-size: 1.2rem;
            border-bottom: 2px solid var(--secondary-color);
            padding-bottom: 0.5rem;
        }

        /* Voltage Control */
        .voltage-control {
            text-align: center;
        }

        .voltage-display {
            font-size: 2rem;
            font-weight: bold;
            color: var(--secondary-color);
            margin-bottom: 1rem;
        }

        .voltage-slider-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .voltage-button {
            background: var(--secondary-color);
            color: white;
            border: none;
            border-radius: 0.25rem;
            width: 40px;
            height: 40px;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .voltage-button:hover {
            background: var(--primary-color);
            transform: translateY(-1px);
        }

        .voltage-button:active {
            transform: translateY(0);
        }

        .voltage-slider {
            -webkit-appearance: none;
            appearance: none;
            width: 150px;
            height: 8px;
            border-radius: 5px;
            background: var(--border-color);
            outline: none;
            transition: background 0.3s;
        }

        .voltage-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: var(--secondary-color);
            cursor: pointer;
            border: 3px solid white;
            box-shadow: var(--shadow);
        }

        .voltage-slider::-moz-range-thumb {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: var(--secondary-color);
            cursor: pointer;
            border: 3px solid white;
            box-shadow: var(--shadow);
        }

        .voltage-range-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.9rem;
            color: var(--text-muted);
            margin-top: 0.5rem;
        }

        /* Configuration Panel */
        .config-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
        }

        .config-item label {
            font-size: 0.9rem;
            color: var(--text-color);
        }

        .config-item input[type="number"] {
            width: 80px;
            padding: 0.25rem 0.5rem;
            border: 1px solid var(--border-color);
            border-radius: 0.25rem;
            font-size: 0.9rem;
        }

        /* Charts Area */
        .charts-container {
            grid-area: charts;
            background: var(--card-background);
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            padding: 1.5rem;
            box-shadow: var(--shadow);
        }

        .chart-wrapper {
            margin-bottom: 2rem;
            position: relative;
        }

        .chart-wrapper:last-child {
            margin-bottom: 0;
        }

        .chart-title {
            font-size: 1.3rem;
            font-weight: 600;
            color: var(--primary-color);
            margin-bottom: 1rem;
            text-align: center;
        }

        .chart-canvas {
            width: 100%;
            max-height: 300px;
        }

        /* Status Panel */
        .status-panel {
            grid-area: status;
            background: var(--card-background);
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            padding: 1.5rem;
            box-shadow: var(--shadow);
        }

        .status-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0;
            border-bottom: 1px solid var(--border-color);
        }

        .status-item:last-child {
            border-bottom: none;
        }

        .status-label {
            font-weight: 600;
            color: var(--text-color);
        }

        .status-value {
            color: var(--text-muted);
            font-family: 'Courier New', monospace;
        }

        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 0.5rem;
        }

        .status-indicator.running {
            background-color: var(--success-color);
            animation: pulse 2s infinite;
        }

        .status-indicator.stopped {
            background-color: var(--text-muted);
        }

        .status-indicator.error {
            background-color: var(--accent-color);
        }

        /* Loading and Error States */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .loading-spinner {
            border: 4px solid var(--border-color);
            border-top: 4px solid var(--secondary-color);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
        }

        .error-message {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
            border-radius: 0.5rem;
            padding: 1rem;
            margin: 1rem 0;
        }

        .access-denied {
            text-align: center;
            padding: 4rem 2rem;
            background: var(--card-background);
            border-radius: 0.5rem;
            box-shadow: var(--shadow-lg);
        }

        .access-denied h1 {
            color: var(--accent-color);
            margin-bottom: 1rem;
        }

        /* Animations */
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .container {
                padding: 0.5rem;
            }

            .header h1 {
                font-size: 1.8rem;
            }

            .voltage-display {
                font-size: 1.5rem;
            }

            .chart-canvas {
                max-height: 250px;
            }
        }
    </style>
</head>
<body>
    <!-- Loading Overlay -->
    <div id="loading-overlay" class="loading-overlay">
        <div>
            <div class="loading-spinner"></div>
            <p style="margin-top: 1rem; text-align: center;">Loading Voltage Tuning Exercise...</p>
            <p id="loading-status" style="text-align: center; color: var(--text-muted);">Initializing Pyodide...</p>
        </div>
    </div>

    <!-- Main Application -->
    <div id="app-container" class="container" style="display: none;">
        <div class="header">
            <h1>Voltage Tuning Exercise</h1>
            <p>Real-time Voltage Control and Power Flow Simulation</p>
        </div>

        <div class="main-grid">
            <!-- Control Panel -->
            <div class="control-panel">
                <div class="control-group">
                    <h3>Voltage Control</h3>
                    <div class="voltage-control">
                        <div class="voltage-display">
                            <span id="voltage-display">1.00</span> pu
                        </div>
                        <div class="voltage-slider-container">
                            <button id="voltage-down" class="voltage-button" title="Decrease voltage reference">▼</button>
                            <input type="range" id="voltage-slider" class="voltage-slider" 
                                   min="90" max="110" value="100" step="0.1">
                            <button id="voltage-up" class="voltage-button" title="Increase voltage reference">▲</button>
                        </div>
                        <div class="voltage-range-labels">
                            <span>90%</span>
                            <span>100%</span>
                            <span>110%</span>
                        </div>
                    </div>
                </div>

                <div class="control-group">
                    <h3>System Parameters</h3>
                    <div class="config-item">
                        <label>Update Rate (ms):</label>
                        <input type="number" id="update-rate" value="50" min="10" max="1000" step="10">
                    </div>
                    <div class="config-item">
                        <label>Noise Level (pu):</label>
                        <input type="number" id="noise-level" value="0.002" min="0" max="0.01" step="0.001">
                    </div>
                    <div class="config-item">
                        <label>System Reactance:</label>
                        <input type="number" id="system-reactance" value="0.05" min="0.01" max="0.2" step="0.01">
                    </div>
                    <div class="config-item">
                        <label>Plant Time Constant:</label>
                        <input type="number" id="plant-time-constant" value="0.25" min="0.1" max="2.0" step="0.05">
                    </div>
                </div>

                <div class="control-group">
                    <h3>Controller Gains</h3>
                    <div class="config-item">
                        <label>Proportional (Kp):</label>
                        <input type="number" id="voltage-kp" value="10.0" min="0.1" max="100" step="0.1">
                    </div>
                    <div class="config-item">
                        <label>Integral (Ki):</label>
                        <input type="number" id="voltage-ki" value="50.0" min="1" max="200" step="1">
                    </div>
                </div>

                <div class="control-group">
                    <button id="reset-simulation" style="width: 100%; padding: 0.75rem; background: var(--warning-color); color: white; border: none; border-radius: 0.5rem; cursor: pointer; font-size: 1rem;">
                        Reset Simulation
                    </button>
                </div>
            </div>

            <!-- Charts Container -->
            <div class="charts-container">
                <div class="chart-wrapper">
                    <div class="chart-title">Voltage Response</div>
                    <canvas id="voltage-chart" class="chart-canvas"></canvas>
                </div>
                <div class="chart-wrapper">
                    <div class="chart-title">Reactive Power Response</div>
                    <canvas id="reactive-chart" class="chart-canvas"></canvas>
                </div>
            </div>

            <!-- Status Panel -->
            <div class="status-panel">
                <h3 style="color: var(--primary-color); margin-bottom: 1rem;">System Status</h3>
                <div class="status-item">
                    <span class="status-label">
                        <span id="status-indicator" class="status-indicator stopped"></span>
                        Simulation
                    </span>
                    <span id="simulation-status" class="status-value">Stopped</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Current Time</span>
                    <span id="current-time" class="status-value">0.00 s</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Iterations</span>
                    <span id="iteration-count" class="status-value">0</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Power Flow</span>
                    <span id="power-flow-status" class="status-value">Converged</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Voltage (Bus 2)</span>
                    <span id="bus-voltage" class="status-value">1.000 pu</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Reactive Power</span>
                    <span id="reactive-power" class="status-value">0.000 pu</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Error Display -->
    <div id="error-display"></div>

    <!-- External Dependencies -->
    <script src="https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <!-- Embedded Python Code -->
    <script type="text/python" id="embedded-newton-raphson">
# Newton-Raphson solver module embedded
"""
Generic Newton-Raphson Power Flow solver for Pyodide environment.
Ported from original NewtonRaphson.py for browser execution.

This maintains identical mathematical precision and algorithm behavior
while being optimized for embedded execution in HTML/JavaScript.
"""

import numpy as np
import math as m

def GenericNewtonRaphson(Ybus_matrix, Vreg_mag, Sgen, 
                        Sload=None, Sload_const_I=None, Sload_const_Y=None,
                        Qgen_min=None, Qgen_max=None, Qgen_cap=None, 
                        initial_V=None, Final_Output=False, Verbose_Output=False):
    """
    Generic Newton-Raphson Power Flow solver
    
    Args:
        Ybus_matrix: N x N matrix representing the admittance of the system
        Vreg_mag: N size vector containing voltage magnitude of regulated buses
                 (None for un-regulated buses)
        Sgen: N size vector containing complex power supplied to each bus
        Sload: N size vector, power from bus (positive values typically)
        ... (additional parameters as per original)
        
    Returns:
        [V, S, solved]: Voltage vector, Power vector, convergence boolean
    """
    
    # Slack bus (known voltage, fixed angle of 0) must be bus 1
    num_buses = len(Ybus_matrix)
    
    # Input validation
    if len(Ybus_matrix[0]) != num_buses:
        raise ValueError("Ybus_matrix must be square")
        
    if len(Vreg_mag) != num_buses:
        raise ValueError("Vreg_mag size mismatch")
    
    if Sload is None:
        Sload = [complex() for x in range(num_buses)]
    
    if len(Sgen) != num_buses or len(Sload) != num_buses:
        raise ValueError("Sgen/Sload size mismatch")
    
    # Additional validation for optional parameters
    for param in [Sload_const_I, Sload_const_Y, Qgen_max, Qgen_min, Qgen_cap]:
        if param is not None and len(param) != num_buses:
            raise ValueError("Optional parameter size mismatch")
    
    # Solver parameters
    TOLERANCE = 1.0e-9
    MAX_ITERATIONS = 200
    
    # Determine which buses have regulated voltage
    Vreg_declared = [Vreg_mag[i] is not None for i in range(num_buses)]
    
    # Convert Ybus to magnitude and angle arrays for faster computation
    Ybus_mag = [[abs(Ybus_matrix[i][j]) for j in range(num_buses)] for i in range(num_buses)]
    Ybus_ang = [[np.angle(Ybus_matrix[i][j], deg=False) for j in range(num_buses)] for i in range(num_buses)]
    
    # Initialize voltage vector
    if initial_V is None:
        V = [complex(real=Vreg_mag[x] if Vreg_declared[x] else Vreg_mag[0], imag=0.0) 
             for x in range(num_buses)]
    else:
        V = [complex(real=initial_V[x].real if not Vreg_declared[x] else Vreg_mag[x],
                    imag=initial_V[x].imag) for x in range(num_buses)]
    
    Vmag = [abs(x) for x in V]
    Vang = [np.angle(x, deg=False) for x in V]
    S = [complex() for x in range(num_buses)]
    
    size = (num_buses - 1) * 2
    mismatch = [0.0 for x in range(size)]
    iteration = 0
    solved = False
    
    def calculate_Jacobian():
        """Calculate Jacobian matrix for Newton-Raphson iteration"""
        jacobian = [[0.0 for x in range(size)] for y in range(size)]
        
        for i in range(1, num_buses):
            for j in range(1, num_buses):
                # del P / del delta (angle)
                if i == j:
                    temp = 0.0
                    for k in range(num_buses):
                        if k != i:
                            temp += (Ybus_mag[i][k] * Vmag[k] * 
                                   m.sin(Vang[i] - Vang[k] - Ybus_ang[i][k]))
                    temp *= -Vmag[i]
                    jacobian[i - 1][j - 1] = temp
                else:
                    jacobian[i - 1][j - 1] = (Vmag[i] * Ybus_mag[i][j] * Vmag[j] * 
                                             m.sin(Vang[i] - Vang[j] - Ybus_ang[i][j]))
                
                # del P / del V (voltage magnitude)
                if i == j:
                    temp = Vmag[i] * Ybus_mag[i][j] * m.cos(Ybus_ang[i][j])
                    for k in range(num_buses):
                        temp += (Ybus_mag[i][k] * Vmag[k] * 
                               m.cos(Vang[i] - Vang[k] - Ybus_ang[i][k]))
                    jacobian[i - 1][j + num_buses - 2] = temp
                else:
                    jacobian[i - 1][j + num_buses - 2] = (Vmag[i] * Ybus_mag[i][j] * 
                                                         m.cos(Vang[i] - Vang[j] - Ybus_ang[i][j]))
                
                # del Q / del delta (angle)
                if i == j:
                    temp = 0.0
                    for k in range(num_buses):
                        if k != i:
                            temp += (Ybus_mag[i][k] * Vmag[k] * 
                                   m.cos(Vang[i] - Vang[k] - Ybus_ang[i][k]))
                    temp *= Vmag[i]
                    jacobian[i + num_buses - 2][j - 1] = temp
                else:
                    jacobian[i + num_buses - 2][j - 1] = (-Vmag[i] * Ybus_mag[i][j] * Vmag[j] * 
                                                         m.cos(Vang[i] - Vang[j] - Ybus_ang[i][j]))
                
                # del Q / del V (voltage magnitude)
                if i == j:
                    temp = -Vmag[i] * Ybus_mag[i][j] * m.sin(Ybus_ang[i][j])
                    for k in range(num_buses):
                        temp += (Ybus_mag[i][k] * Vmag[k] * 
                               m.sin(Vang[i] - Vang[k] - Ybus_ang[i][k]))
                    jacobian[i + num_buses - 2][j + num_buses - 2] = temp
                else:
                    jacobian[i + num_buses - 2][j + num_buses - 2] = (Vmag[i] * Ybus_mag[i][j] * 
                                                                     m.sin(Vang[i] - Vang[j] - Ybus_ang[i][j]))
        
        return jacobian
    
    # Main Newton-Raphson iteration loop
    while True:
        jacobian = calculate_Jacobian()
        
        # Update voltage phasors
        for i in range(1, num_buses):
            V[i] = complex(real=Vmag[i] * m.cos(Vang[i]),
                          imag=Vmag[i] * m.sin(Vang[i]))
        
        # Calculate currents and power
        I = np.matmul(Ybus_matrix, V)
        S = [V[i] * np.conjugate(I[i]) for i in range(num_buses)]
        
        if Verbose_Output and iteration < 3:  # Limit verbose output in browser
            print(f'-------- Iteration {iteration + 1} --------')
            for i in range(num_buses):
                print(f'V{i+1} = {Vmag[i]:.6f} pu, d{i+1} = {Vang[i]:.6f} rad, '
                      f'P{i+1} = {S[i].real:.6f} pu, Q{i+1} = {S[i].imag:.6f} pu')
        
        # Determine voltage regulation status
        Vregulating = [False for x in range(num_buses)]
        
        for i in range(1, num_buses):
            if Vreg_declared[i]:
                under = False
                over = False
                
                # Check reactive power limits
                if Qgen_min is not None and Qgen_min[i] is not None:
                    if (S[i].imag + Sload[i].imag) <= Qgen_min[i] or Vmag[i] > Vreg_mag[i]:
                        under = True
                        Sgen[i] = complex(real=Sgen[i].real, imag=Qgen_min[i])
                
                if Qgen_max is not None and Qgen_max[i] is not None:
                    if (S[i].imag + Sload[i].imag) >= Qgen_max[i] or Vmag[i] < Vreg_mag[i]:
                        over = True
                        Sgen[i] = complex(real=Sgen[i].real, imag=Qgen_max[i])
                
                # Handle callable reactive limits (if implemented)
                if Qgen_cap is not None and Qgen_cap[i] is not None:
                    try:
                        Qmin_val, Qmax_val = Qgen_cap[i](Vpu=Vmag[i], Ppu=Sgen[i].real)
                        if (S[i].imag + Sload[i].imag) <= Qmin_val or Vmag[i] > Vreg_mag[i]:
                            if under:
                                Qmin_limit = max(Sgen[i].imag, Qmin_val)
                                Sgen[i] = complex(real=Sgen[i].real, imag=Qmin_limit)
                            else:
                                Sgen[i] = complex(real=Sgen[i].real, imag=Qmin_val)
                                under = True
                        
                        if (S[i].imag + Sload[i].imag) >= Qmax_val or Vmag[i] < Vreg_mag[i]:
                            if over:
                                Qmax_limit = min(Sgen[i].imag, Qmax_val)
                                Sgen[i] = complex(real=Sgen[i].real, imag=Qmax_limit)
                            else:
                                Sgen[i] = complex(real=Sgen[i].real, imag=Qmax_val)
                                over = True
                    except Exception as e:
                        if Verbose_Output:
                            print(f"Reactive limit calculation error: {e}")
                
                Vregulating[i] = (not under) and (not over)
            
            # Calculate net power injection
            Snet = Sgen[i] - Sload[i]
            
            # Apply constant current loads
            if Sload_const_I is not None and Sload_const_I[i] is not None:
                Snet -= (Vmag[i] * Sload_const_I[i])
            
            # Apply constant admittance loads
            if Sload_const_Y is not None and Sload_const_Y[i] is not None:
                Snet -= (m.pow(Vmag[i], 2) * Sload_const_Y[i])
            
            # Calculate power mismatch
            Serr = Snet - S[i]
            
            # Set up mismatch vector
            mismatch[i - 1] = Serr.real
            
            if Vregulating[i]:
                mismatch[i + num_buses - 2] = 0.0
            else:
                mismatch[i + num_buses - 2] = Serr.imag
        
        # Solve for corrections
        try:
            del_val = np.matmul(np.linalg.inv(jacobian), mismatch)
        except np.linalg.LinAlgError:
            if Verbose_Output:
                print("Singular Jacobian matrix - no solution found")
            break
        
        # Apply corrections
        for i in range(1, num_buses):
            Vang[i] += del_val[i - 1]
            
            if Vreg_declared[i]:
                if Vregulating[i]:
                    Vmag[i] = Vreg_mag[i]
                else:
                    # Apply voltage magnitude correction with limits
                    if Vmag[i] > Vreg_mag[i]:
                        if del_val[i + num_buses - 2] < (Vreg_mag[i] - Vmag[i]):
                            Vmag[i] = Vreg_mag[i]
                        else:
                            Vmag[i] += del_val[i + num_buses - 2]
                    elif Vmag[i] < Vreg_mag[i]:
                        if del_val[i + num_buses - 2] > (Vreg_mag[i] - Vmag[i]):
                            Vmag[i] = Vreg_mag[i]
                        else:
                            Vmag[i] += del_val[i + num_buses - 2]
                    else:
                        Vmag[i] += del_val[i + num_buses - 2]
            else:
                Vmag[i] += del_val[i + num_buses - 2]
        
        iteration += 1
        
        # Check for convergence or maximum iterations
        if len(del_val) > 0:
            max_mismatch = max(np.max(del_val), -np.min(del_val))
        else:
            max_mismatch = float('inf')
        
        if iteration >= MAX_ITERATIONS:
            if Verbose_Output:
                print('MAXIMUM ITERATIONS REACHED! NO SOLUTION FOUND.')
            break
        elif max_mismatch <= TOLERANCE:
            solved = True
            if Verbose_Output:
                print(f'Converged in {iteration} iterations with tolerance {TOLERANCE}')
            break
    
    # Final voltage calculation
    for i in range(1, num_buses):
        V[i] = complex(real=Vmag[i] * m.cos(Vang[i]),
                      imag=Vmag[i] * m.sin(Vang[i]))
    
    # Final power calculation
    I = np.matmul(Ybus_matrix, V)
    S = [V[i] * np.conjugate(I[i]) for i in range(num_buses)]
    
    if Verbose_Output or Final_Output:
        print('\nFinal solution:')
        for i in range(num_buses):
            print(f'V{i+1} = {Vmag[i]:.6f} pu, d{i+1} = {Vang[i]:.6f} rad, '
                  f'P{i+1} = {S[i].real:.6f} pu, Q{i+1} = {S[i].imag:.6f} pu')
    
    return [V, S, solved]


def pretty_print_matrix(matrix):
    """Pretty print matrix for debugging purposes"""
    return '\n'.join(['\t'.join([f'{x:.6f}' for x in row]) for row in matrix])


def pretty_print_vector(vector):
    """Pretty print vector for debugging purposes"""
    return '\n'.join([f'{x}' for x in vector])
    </script>

    <script type="text/python" id="embedded-reactive-control">
# Reactive control system module
import numpy as np
import random

class SimulationState:
    """Global simulation state management"""
    
    def __init__(self):
        # Simulation parameters (configurable)
        self.DELT = 0.05  # 50ms time step
        self.SYS_XE = 0.05  # System reactance, pu on 100 MVA base
        self.TQ_PLANT = 0.25  # Plant time constant, seconds
        self.VCTRL_KP = 10.0  # Voltage controller proportional gain
        self.VCTRL_KI = 50.0  # Voltage controller integral gain
        self.NOISE = 0.002  # Voltage noise level, pu
        
        # System initial conditions
        self.VINIT = 1.0  # Initial voltage magnitude, pu
        self.PINIT = 0.8  # Active power setpoint, pu (not variable in this version)
        self.QINIT = 0.0  # Initial reactive power, pu
        
        # Controller state variables
        self.TQ_STORE = 0.0  # Plant integrator state
        self.KI_STORE = self.QINIT  # Voltage controller integrator state
        
        # System calculations
        self.IINIT = np.conjugate(complex(self.PINIT, self.QINIT)) / self.VINIT
        self.VSYS = abs(self.VINIT - self.IINIT * complex(0, self.SYS_XE))
        
        # Data storage for visualization (rolling window)
        self.max_data_points = 200  # 10 seconds at 50ms intervals
        self.time_vals = []
        self.voltage_vals = []
        self.voltage_ref_vals = []
        self.reactive_vals = []
        self.reactive_ref_vals = []
        
        # Initialize with starting values
        self.initialize_data()
        
        # System admittance matrix
        self.setup_ybus_matrix()
        
        # Current simulation time
        self.current_time = 0.0
        
        # Performance tracking
        self.iteration_count = 0
    
    def initialize_data(self):
        """Initialize data arrays with starting values"""
        # Start with two initial points for smooth animation startup
        start_time = -2 * self.DELT
        self.time_vals = [start_time, start_time + self.DELT]
        self.voltage_vals = [1.0, 1.0]
        self.voltage_ref_vals = [1.0, 1.0]
        self.reactive_vals = [0.0, 0.0]
        self.reactive_ref_vals = [0.0, 0.0]
    
    def setup_ybus_matrix(self):
        """Create the 2-bus system admittance matrix"""
        num_buses = 2
        self.Ybus_matrix = [[complex() for c in range(num_buses)] for r in range(num_buses)]
        
        # System impedance and admittance
        Sys_Z = complex(0.0, self.SYS_XE)
        Yext = 1.0 / Sys_Z
        
        # Build admittance matrix for 2-bus system
        self.Ybus_matrix[0][0] = Yext
        self.Ybus_matrix[0][1] = -Yext
        self.Ybus_matrix[1][0] = -Yext
        self.Ybus_matrix[1][1] = Yext
    
    def update_parameters(self, param_dict):
        """Update simulation parameters dynamically"""
        updated_params = []
        
        if 'simulation_interval' in param_dict:
            self.DELT = param_dict['simulation_interval'] / 1000.0
            updated_params.append('simulation_interval')
        
        if 'noise_level' in param_dict:
            self.NOISE = param_dict['noise_level']
            updated_params.append('noise_level')
        
        if 'system_reactance' in param_dict:
            self.SYS_XE = param_dict['system_reactance']
            self.setup_ybus_matrix()  # Rebuild Ybus matrix
            updated_params.append('system_reactance')
        
        if 'plant_time_constant' in param_dict:
            self.TQ_PLANT = param_dict['plant_time_constant']
            updated_params.append('plant_time_constant')
        
        if 'voltage_kp' in param_dict:
            self.VCTRL_KP = param_dict['voltage_kp']
            updated_params.append('voltage_kp')
        
        if 'voltage_ki' in param_dict:
            self.VCTRL_KI = param_dict['voltage_ki']
            updated_params.append('voltage_ki')
        
        if 'active_power' in param_dict:
            self.PINIT = param_dict['active_power']
            updated_params.append('active_power')
        
        return updated_params
    
    def maintain_rolling_window(self):
        """Maintain rolling window of data for visualization"""
        while len(self.time_vals) > self.max_data_points:
            self.time_vals.pop(0)
            self.voltage_vals.pop(0)
            self.voltage_ref_vals.pop(0)
            self.reactive_vals.pop(0)
            self.reactive_ref_vals.pop(0)
        
        # Also remove old data based on time window (10 seconds)
        current_time = max(self.time_vals) if self.time_vals else 0
        while (self.time_vals and 
               len(self.time_vals) > 2 and 
               self.time_vals[0] < current_time - 10.0):
            self.time_vals.pop(0)
            self.voltage_vals.pop(0)
            self.voltage_ref_vals.pop(0)
            self.reactive_vals.pop(0)
            self.reactive_ref_vals.pop(0)
    
    def get_current_data(self):
        """Get current simulation data for JavaScript interface"""
        return {
            'time_values': self.time_vals.copy(),
            'voltage_reference': self.voltage_ref_vals.copy(),
            'voltage_actual': self.voltage_vals.copy(),
            'reactive_reference': self.reactive_ref_vals.copy(),
            'reactive_actual': self.reactive_vals.copy(),
            'current_time': self.current_time,
            'iteration_count': self.iteration_count,
            'converged': True  # Will be updated by simulation step
        }
    
    def reset_simulation(self):
        """Reset simulation to initial conditions"""
        self.TQ_STORE = 0.0
        self.KI_STORE = self.QINIT
        self.current_time = 0.0
        self.iteration_count = 0
        self.initialize_data()

# Global simulation state instance
sim_state = SimulationState()

def simulate_step(voltage_reference):
    """Execute one simulation step"""
    global sim_state
    
    try:
        # Update simulation time
        sim_state.current_time += sim_state.DELT
        sim_state.time_vals.append(sim_state.current_time)
        
        # Store voltage reference
        sim_state.voltage_ref_vals.append(float(voltage_reference))
        
        # Voltage control loop - PI controller
        if len(sim_state.voltage_vals) > 0:
            error = voltage_reference - sim_state.voltage_vals[-1]
        else:
            error = 0.0
        
        # PI control calculation
        DSTATE = error * sim_state.VCTRL_KI
        sim_state.KI_STORE += DSTATE * sim_state.DELT
        
        # PI controller output (reactive power command)
        Qcmd = (error * sim_state.VCTRL_KP + 
                sim_state.KI_STORE + 
                sim_state.DELT * DSTATE / 2.0)
        
        sim_state.reactive_ref_vals.append(Qcmd)
        
        # Plant dynamics - first-order lag
        if len(sim_state.reactive_vals) > 0:
            q_last = sim_state.reactive_vals[-1]
        else:
            q_last = sim_state.QINIT
        
        q_err = Qcmd - q_last
        
        # First-order plant response
        DSTATE = q_err / sim_state.TQ_PLANT
        sim_state.TQ_STORE += DSTATE * sim_state.DELT
        
        # Plant output with trapezoidal integration
        q_new = sim_state.TQ_STORE + sim_state.DELT * DSTATE / 2.0
        sim_state.reactive_vals.append(q_new)
        
        # Power flow calculation with noise
        Vsys = sim_state.VSYS + (random.random() - 0.5) * 2.0 * sim_state.NOISE
        
        # Newton-Raphson power flow solution
        try:
            Vout, Sout, solved = GenericNewtonRaphson(
                Ybus_matrix=sim_state.Ybus_matrix,
                Vreg_mag=[complex(Vsys), None],
                Sgen=[None, complex(sim_state.PINIT, q_new)],
                Verbose_Output=False
            )
            
            # Extract voltage magnitude at bus 2 (load bus)
            v_new = abs(Vout[1])
            sim_state.voltage_vals.append(v_new)
            
            convergence_status = solved
            
        except Exception as e:
            # Handle power flow solution failure
            print(f"Power flow solution error: {e}")
            # Use previous voltage value if available
            if len(sim_state.voltage_vals) > 0:
                sim_state.voltage_vals.append(sim_state.voltage_vals[-1])
            else:
                sim_state.voltage_vals.append(sim_state.VINIT)
            convergence_status = False
        
        # Maintain rolling data window
        sim_state.maintain_rolling_window()
        
        # Update iteration counter
        sim_state.iteration_count += 1
        
        # Prepare return data
        result = {
            'time': sim_state.current_time,
            'voltage_reference': voltage_reference,
            'voltage_actual': sim_state.voltage_vals[-1],
            'reactive_reference': Qcmd,
            'reactive_actual': q_new,
            'converged': convergence_status,
            'iteration': sim_state.iteration_count,
            'data_arrays': sim_state.get_current_data()
        }
        
        return result
        
    except Exception as e:
        # Handle any unexpected errors
        print(f"Simulation step error: {e}")
        return {
            'time': sim_state.current_time,
            'voltage_reference': voltage_reference,
            'voltage_actual': 1.0,
            'reactive_reference': 0.0,
            'reactive_actual': 0.0,
            'converged': False,
            'error': str(e),
            'iteration': sim_state.iteration_count,
            'data_arrays': sim_state.get_current_data()
        }

def update_simulation_parameters(param_dict):
    """Update simulation parameters from JavaScript"""
    global sim_state
    return sim_state.update_parameters(param_dict)

def get_simulation_data():
    """Get current simulation data arrays for plotting"""
    global sim_state
    return sim_state.get_current_data()

def reset_simulation():
    """Reset simulation to initial conditions"""
    global sim_state
    sim_state.reset_simulation()
    return True

def get_simulation_config():
    """Get current simulation configuration"""
    global sim_state
    
    return {
        'simulation_interval': sim_state.DELT * 1000.0,  # Convert to milliseconds
        'noise_level': sim_state.NOISE,
        'system_reactance': sim_state.SYS_XE,
        'plant_time_constant': sim_state.TQ_PLANT,
        'voltage_kp': sim_state.VCTRL_KP,
        'voltage_ki': sim_state.VCTRL_KI,
        'active_power': sim_state.PINIT,
        'system_voltage': sim_state.VSYS,
        'max_data_points': sim_state.max_data_points
    }

def validate_simulation_health():
    """Check simulation health and provide diagnostics"""
    global sim_state
    
    health_status = {
        'status': 'healthy',
        'warnings': [],
        'data_points': len(sim_state.time_vals),
        'current_time': sim_state.current_time,
        'iteration_count': sim_state.iteration_count
    }
    
    return health_status
    </script>

    <!-- Main JavaScript Application -->
    <script>
// Security Manager
class SecurityManager {
    constructor() {
        this.config = {
            startDate: "2024-02-01",
            expirationDays: 90,
            bypassEnabled: true,
            adminKey: "reactive_admin_2024"
        };
    }

    checkAccess() {
        const now = new Date();
        const startDate = new Date(this.config.startDate);
        const expirationDate = new Date(startDate.getTime() + 
                                       this.config.expirationDays * 24 * 60 * 60 * 1000);

        // Check for bypass first
        if (this.config.bypassEnabled && this.checkBypass()) {
            return { allowed: true, reason: "bypass" };
        }

        // Check date range
        if (now < startDate) {
            return { 
                allowed: false, 
                reason: "not_started",
                message: `Training materials available starting ${startDate.toDateString()}`
            };
        }

        if (now > expirationDate) {
            return { 
                allowed: false, 
                reason: "expired",
                message: `Training materials expired on ${expirationDate.toDateString()}`
            };
        }

        return { allowed: true, reason: "valid" };
    }

    checkBypass() {
        // Check URL parameters
        const params = new URLSearchParams(window.location.search);
        if (params.get('admin') === this.config.adminKey) {
            return true;
        }

        // Check localStorage
        if (localStorage.getItem('reactive_admin') === this.config.adminKey) {
            return true;
        }

        // Check for development environment indicators
        if (window.location.hostname === 'localhost' || 
            window.location.hostname === '127.0.0.1' ||
            window.location.protocol === 'file:') {
            return true;
        }

        return false;
    }

    showAccessDenied(accessResult) {
        const container = document.getElementById('app-container');
        const loading = document.getElementById('loading-overlay');
        
        loading.style.display = 'none';
        container.innerHTML = `
            <div class="access-denied">
                <h1>Access Not Available</h1>
                <p>${accessResult.message}</p>
                <p>Please contact your training coordinator for assistance.</p>
                <hr style="margin: 2rem 0;">
                <p style="font-size: 0.9rem; color: var(--text-muted);">
                    If you are an administrator, you can bypass this check by adding 
                    <code>?admin=${this.config.adminKey}</code> to the URL.
                </p>
            </div>
        `;
        container.style.display = 'block';
    }
}

// Pyodide Bridge
class PyodideBridge {
    constructor() {
        this.pyodide = null;
        this.isInitialized = false;
        this.simulationFunctions = {};
    }

    async initialize() {
        try {
            console.log('Loading Pyodide...');
            this.updateLoadingStatus('Loading Pyodide runtime...');
            
            this.pyodide = await loadPyodide();
            console.log('Pyodide loaded successfully');

            this.updateLoadingStatus('Loading NumPy...');
            await this.pyodide.loadPackage(['numpy']);
            console.log('NumPy loaded successfully');

            this.updateLoadingStatus('Loading Python modules...');
            await this.loadEmbeddedPythonCode();
            
            this.updateLoadingStatus('Initializing simulation...');
            await this.setupPythonFunctions();

            this.isInitialized = true;
            console.log('PyodideBridge initialized successfully');
            
            return true;

        } catch (error) {
            console.error('Failed to initialize PyodideBridge:', error);
            this.showError(`Failed to initialize simulation environment: ${error.message}`);
            return false;
        }
    }

    updateLoadingStatus(message) {
        const statusElement = document.getElementById('loading-status');
        if (statusElement) {
            statusElement.textContent = message;
        }
    }

    async loadEmbeddedPythonCode() {
        // Load Newton-Raphson solver from embedded script
        const newtonRaphsonScript = document.getElementById('embedded-newton-raphson');
        if (newtonRaphsonScript) {
            this.pyodide.runPython(newtonRaphsonScript.textContent);
            console.log('Newton-Raphson solver loaded');
        }

        // Load reactive control system from embedded script
        const reactiveControlScript = document.getElementById('embedded-reactive-control');
        if (reactiveControlScript) {
            this.pyodide.runPython(reactiveControlScript.textContent);
            console.log('Reactive control system loaded');
        }
    }

    async setupPythonFunctions() {
        // Get references to Python functions
        this.simulationFunctions = {
            simulate_step: this.pyodide.globals.get('simulate_step'),
            update_simulation_parameters: this.pyodide.globals.get('update_simulation_parameters'),
            get_simulation_data: this.pyodide.globals.get('get_simulation_data'),
            reset_simulation: this.pyodide.globals.get('reset_simulation'),
            get_simulation_config: this.pyodide.globals.get('get_simulation_config'),
            validate_simulation_health: this.pyodide.globals.get('validate_simulation_health')
        };

        // Verify all functions are available
        for (const [name, func] of Object.entries(this.simulationFunctions)) {
            if (!func) {
                throw new Error(`Python function not found: ${name}`);
            }
        }
    }

    callPythonFunction(functionName, ...args) {
        if (!this.isInitialized) {
            throw new Error('PyodideBridge not initialized');
        }

        const func = this.simulationFunctions[functionName];
        if (!func) {
            throw new Error(`Python function not found: ${functionName}`);
        }

        try {
            const result = func(...args);
            return result.toJs({dict_converter: Object.fromEntries});
        } catch (error) {
            console.error(`Error calling Python function ${functionName}:`, error);
            throw error;
        }
    }

    showError(message) {
        const errorDisplay = document.getElementById('error-display');
        if (errorDisplay) {
            errorDisplay.innerHTML = `
                <div class="error-message">
                    <strong>Error:</strong> ${message}
                </div>
            `;
        }
    }
}

// Chart Manager
class ChartManager {
    constructor() {
        this.voltageChart = null;
        this.reactiveChart = null;
        this.maxDataPoints = 200; // 10 seconds at 50ms
    }

    initialize() {
        this.initializeVoltageChart();
        this.initializeReactiveChart();
    }

    initializeVoltageChart() {
        const ctx = document.getElementById('voltage-chart').getContext('2d');
        
        this.voltageChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    label: 'Voltage Reference',
                    data: [],
                    borderColor: '#e74c3c',
                    backgroundColor: 'rgba(231, 76, 60, 0.1)',
                    fill: false,
                    tension: 0.1,
                    pointRadius: 0,
                    pointHoverRadius: 4,
                    borderWidth: 2
                }, {
                    label: 'Voltage Actual',
                    data: [],
                    borderColor: '#3498db',
                    backgroundColor: 'rgba(52, 152, 219, 0.1)',
                    fill: false,
                    tension: 0.1,
                    pointRadius: 0,
                    pointHoverRadius: 4,
                    borderWidth: 2
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: true,
                        position: 'top'
                    }
                },
                scales: {
                    x: {
                        type: 'linear',
                        title: {
                            display: true,
                            text: 'Time (seconds)'
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'Voltage (pu)'
                        },
                        min: 0.85,
                        max: 1.15
                    }
                },
                animation: {
                    duration: 0 // Disable animation for real-time updates
                }
            }
        });
    }

    initializeReactiveChart() {
        const ctx = document.getElementById('reactive-chart').getContext('2d');
        
        this.reactiveChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    label: 'Reactive Reference',
                    data: [],
                    borderColor: '#e74c3c',
                    backgroundColor: 'rgba(231, 76, 60, 0.1)',
                    fill: false,
                    tension: 0.1,
                    pointRadius: 0,
                    pointHoverRadius: 4,
                    borderWidth: 2
                }, {
                    label: 'Reactive Actual',
                    data: [],
                    borderColor: '#27ae60',
                    backgroundColor: 'rgba(39, 174, 96, 0.1)',
                    fill: false,
                    tension: 0.1,
                    pointRadius: 0,
                    pointHoverRadius: 4,
                    borderWidth: 2
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: true,
                        position: 'top'
                    }
                },
                scales: {
                    x: {
                        type: 'linear',
                        title: {
                            display: true,
                            text: 'Time (seconds)'
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'Reactive Power (pu)'
                        }
                    }
                },
                animation: {
                    duration: 0
                }
            }
        });
    }

    updateCharts(data) {
        if (!data || !data.data_arrays) {
            return;
        }

        const chartData = data.data_arrays;
        
        // Update voltage chart
        this.updateChart(this.voltageChart, chartData.time_values, [
            { data: chartData.voltage_reference, label: 'Voltage Reference' },
            { data: chartData.voltage_actual, label: 'Voltage Actual' }
        ]);

        // Update reactive power chart
        this.updateChart(this.reactiveChart, chartData.time_values, [
            { data: chartData.reactive_reference, label: 'Reactive Reference' },
            { data: chartData.reactive_actual, label: 'Reactive Actual' }
        ]);
    }

    updateChart(chart, timeData, datasets) {
        if (!chart || !timeData || timeData.length === 0) {
            return;
        }

        // Update time labels
        chart.data.labels = timeData;

        // Update datasets
        datasets.forEach((dataset, index) => {
            if (chart.data.datasets[index] && dataset.data) {
                chart.data.datasets[index].data = timeData.map((time, i) => ({
                    x: time,
                    y: dataset.data[i] || 0
                }));
            }
        });

        // Set x-axis range for 10-second rolling window
        const latestTime = timeData[timeData.length - 1] || 0;
        const minTime = Math.max(0, latestTime - 10);
        const maxTime = Math.max(10, latestTime);

        chart.options.scales.x.min = minTime;
        chart.options.scales.x.max = maxTime;

        // Update chart without animation
        chart.update('none');
    }

    resetCharts() {
        if (this.voltageChart) {
            this.voltageChart.data.labels = [];
            this.voltageChart.data.datasets.forEach(dataset => {
                dataset.data = [];
            });
            this.voltageChart.update('none');
        }

        if (this.reactiveChart) {
            this.reactiveChart.data.labels = [];
            this.reactiveChart.data.datasets.forEach(dataset => {
                dataset.data = [];
            });
            this.reactiveChart.update('none');
        }
    }
}

// Simulation Controller
class SimulationController {
    constructor(bridge, chartManager) {
        this.bridge = bridge;
        this.chartManager = chartManager;
        this.isRunning = false;
        this.simulationTimer = null;
        this.updateInterval = 50; // milliseconds
        this.voltageReference = 1.0; // per unit
    }

    start() {
        if (this.isRunning || !this.bridge.isInitialized) {
            return;
        }

        console.log('Starting simulation...');
        this.isRunning = true;
        this.updateSimulationStatus('Running');

        this.simulationTimer = setInterval(() => {
            this.step();
        }, this.updateInterval);
    }

    stop() {
        if (!this.isRunning) {
            return;
        }

        console.log('Stopping simulation...');
        this.isRunning = false;
        this.updateSimulationStatus('Stopped');

        if (this.simulationTimer) {
            clearInterval(this.simulationTimer);
            this.simulationTimer = null;
        }
    }

    step() {
        try {
            // Execute Python simulation step
            const result = this.bridge.callPythonFunction('simulate_step', this.voltageReference);
            
            // Update charts
            this.chartManager.updateCharts(result);
            
            // Update status display
            this.updateStatusDisplay(result);

        } catch (error) {
            console.error('Simulation step error:', error);
            this.stop();
            this.bridge.showError(`Simulation error: ${error.message}`);
        }
    }

    setVoltageReference(value) {
        this.voltageReference = parseFloat(value) / 100.0; // Convert percentage to per-unit
        
        // Update display
        const display = document.getElementById('voltage-display');
        if (display) {
            display.textContent = this.voltageReference.toFixed(2);
        }
    }

    updateParameters(params) {
        try {
            const updated = this.bridge.callPythonFunction('update_simulation_parameters', params);
            console.log('Updated parameters:', updated);

            // Update simulation interval if changed
            if (params.simulation_interval) {
                this.updateInterval = params.simulation_interval;
                
                // Restart simulation with new interval
                if (this.isRunning) {
                    this.stop();
                    setTimeout(() => this.start(), 100);
                }
            }

        } catch (error) {
            console.error('Parameter update error:', error);
            this.bridge.showError(`Parameter update failed: ${error.message}`);
        }
    }

    resetSimulation() {
        try {
            this.stop();
            this.bridge.callPythonFunction('reset_simulation');
            this.chartManager.resetCharts();
            this.updateStatusDisplay({
                current_time: 0,
                iteration: 0,
                voltage_actual: 1.0,
                reactive_actual: 0.0,
                converged: true
            });
            console.log('Simulation reset');
        } catch (error) {
            console.error('Reset error:', error);
            this.bridge.showError(`Reset failed: ${error.message}`);
        }
    }

    updateSimulationStatus(status) {
        const statusElement = document.getElementById('simulation-status');
        const indicatorElement = document.getElementById('status-indicator');
        
        if (statusElement) {
            statusElement.textContent = status;
        }
        
        if (indicatorElement) {
            indicatorElement.className = `status-indicator ${status.toLowerCase()}`;
        }
    }

    updateStatusDisplay(data) {
        const updates = {
            'current-time': data.current_time ? `${data.current_time.toFixed(2)} s` : '0.00 s',
            'iteration-count': data.iteration || '0',
            'power-flow-status': data.converged ? 'Converged' : 'Failed',
            'bus-voltage': data.voltage_actual ? `${data.voltage_actual.toFixed(3)} pu` : '1.000 pu',
            'reactive-power': data.reactive_actual ? `${data.reactive_actual.toFixed(3)} pu` : '0.000 pu'
        };

        for (const [id, value] of Object.entries(updates)) {
            const element = document.getElementById(id);
            if (element) {
                element.textContent = value;
            }
        }
    }
}

// Main Application
class ReactiveCapabilityApp {
    constructor() {
        this.security = new SecurityManager();
        this.bridge = new PyodideBridge();
        this.chartManager = new ChartManager();
        this.simulationController = null;
        this.isInitialized = false;
    }

    async initialize() {
        try {
            // Check access permissions
            const accessCheck = this.security.checkAccess();
            if (!accessCheck.allowed) {
                this.security.showAccessDenied(accessCheck);
                return false;
            }

            console.log('Access granted:', accessCheck.reason);

            // Initialize Python bridge
            const bridgeInitialized = await this.bridge.initialize();
            if (!bridgeInitialized) {
                return false;
            }

            // Initialize charts
            this.chartManager.initialize();

            // Initialize simulation controller
            this.simulationController = new SimulationController(this.bridge, this.chartManager);

            // Set up UI event handlers
            this.setupEventHandlers();

            // Initialize UI values
            this.initializeUI();

            // Hide loading overlay and show application
            document.getElementById('loading-overlay').style.display = 'none';
            document.getElementById('app-container').style.display = 'block';

            this.isInitialized = true;
            console.log('Voltage Tuning Exercise initialized successfully');

            // Auto-start simulation
            setTimeout(() => {
                if (this.simulationController) {
                    this.simulationController.start();
                }
            }, 1000);

            return true;

        } catch (error) {
            console.error('Application initialization error:', error);
            this.bridge.showError(`Application initialization failed: ${error.message}`);
            return false;
        }
    }

    setupEventHandlers() {
        // Voltage control handlers
        const voltageSlider = document.getElementById('voltage-slider');
        const voltageUp = document.getElementById('voltage-up');
        const voltageDown = document.getElementById('voltage-down');

        if (voltageSlider) {
            voltageSlider.addEventListener('input', (e) => {
                this.simulationController.setVoltageReference(e.target.value);
            });
        }

        if (voltageUp) {
            voltageUp.addEventListener('click', () => {
                const currentValue = parseFloat(voltageSlider.value);
                const newValue = Math.min(110, currentValue + 0.5);
                voltageSlider.value = newValue;
                this.simulationController.setVoltageReference(newValue);
            });
        }

        if (voltageDown) {
            voltageDown.addEventListener('click', () => {
                const currentValue = parseFloat(voltageSlider.value);
                const newValue = Math.max(90, currentValue - 0.5);
                voltageSlider.value = newValue;
                this.simulationController.setVoltageReference(newValue);
            });
        }

        // Parameter update handlers
        const parameterInputs = [
            'update-rate', 'noise-level', 'system-reactance', 
            'plant-time-constant', 'voltage-kp', 'voltage-ki'
        ];

        parameterInputs.forEach(id => {
            const element = document.getElementById(id);
            if (element) {
                element.addEventListener('change', () => {
                    this.updateSimulationParameters();
                });
            }
        });

        // Reset button handler
        const resetButton = document.getElementById('reset-simulation');
        if (resetButton) {
            resetButton.addEventListener('click', () => {
                this.simulationController.resetSimulation();
            });
        }

        // Window event handlers
        window.addEventListener('beforeunload', () => {
            if (this.simulationController) {
                this.simulationController.stop();
            }
        });
    }

    initializeUI() {
        // Set initial voltage reference
        this.simulationController.setVoltageReference(100);
    }

    updateSimulationParameters() {
        const params = {
            simulation_interval: parseInt(document.getElementById('update-rate').value),
            noise_level: parseFloat(document.getElementById('noise-level').value),
            system_reactance: parseFloat(document.getElementById('system-reactance').value),
            plant_time_constant: parseFloat(document.getElementById('plant-time-constant').value),
            voltage_kp: parseFloat(document.getElementById('voltage-kp').value),
            voltage_ki: parseFloat(document.getElementById('voltage-ki').value)
        };

        this.simulationController.updateParameters(params);
    }
}

// Initialize application when DOM is loaded
document.addEventListener('DOMContentLoaded', async () => {
    console.log('DOM loaded, initializing Voltage Tuning Exercise...');
    
    const app = new VoltageExerciseApp();
    const success = await app.initialize();
    
    if (!success) {
        console.error('Failed to initialize application');
    }
});

// Export for debugging
window.ReactiveCapabilityApp = ReactiveCapabilityApp;
    </script>
</body>
</html>