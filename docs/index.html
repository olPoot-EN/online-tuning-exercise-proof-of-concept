<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voltage Tuning Exercise</title>
    
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <!-- Loading Overlay -->
    <div id="loading-overlay" class="loading-overlay">
        <div>
            <div class="loading-spinner"></div>
            <p style="margin-top: 1rem; text-align: center;">Loading Voltage Tuning Exercise...</p>
            <p id="loading-status" style="text-align: center; color: var(--text-muted);">Initializing Pyodide...</p>
        </div>
    </div>

    <!-- Main Application -->
    <div id="app-container" class="container" style="display: none;">
        <div class="header">
            <h1>Voltage Tuning Exercise</h1>
            <p>Real-time Voltage Control and Power Flow Simulation</p>
        </div>

        <div class="main-grid">
            <!-- Control Panel -->
            <div class="control-panel">
                <div class="control-group">
                    <h3>Voltage Control</h3>
                    <div class="voltage-control">
                        <div class="voltage-display">
                            <span id="voltage-display">1.00</span> pu
                        </div>
                        <div class="voltage-slider-container">
                            <button id="voltage-down" class="voltage-button" title="Decrease voltage reference">▼</button>
                            <input type="range" id="voltage-slider" class="voltage-slider" 
                                   min="90" max="110" value="100" step="0.1">
                            <button id="voltage-up" class="voltage-button" title="Increase voltage reference">▲</button>
                        </div>
                        <div class="voltage-range-labels">
                            <span>90%</span>
                            <span>100%</span>
                            <span>110%</span>
                        </div>
                    </div>
                </div>

                <div class="control-group">
                    <h3>System Parameters</h3>
                    <div class="config-item">
                        <label>Update Rate (ms):</label>
                        <input type="number" id="update-rate" value="50" min="10" max="1000" step="10">
                    </div>
                    <div class="config-item">
                        <label>Noise Level (pu):</label>
                        <input type="number" id="noise-level" value="0.002" min="0" max="0.01" step="0.001">
                    </div>
                    <div class="config-item">
                        <label>System Reactance (pu):</label>
                        <input type="number" id="system-reactance" value="0.05" min="0.01" max="0.2" step="0.01">
                    </div>
                    <div class="config-item">
                        <label>Plant Time Constant (s):</label>
                        <input type="number" id="plant-time-constant" value="0.25" min="0.1" max="2.0" step="0.05">
                    </div>
                </div>

                <div class="control-group">
                    <h3>Controller Gains</h3>
                    <div class="config-item">
                        <label>Proportional (Kp):</label>
                        <input type="number" id="voltage-kp" value="10.0" min="0.1" max="100" step="0.1">
                    </div>
                    <div class="config-item">
                        <label>Integral (Ki):</label>
                        <input type="number" id="voltage-ki" value="50.0" min="1" max="200" step="1">
                    </div>
                </div>

                <div class="control-group">
                    <h3>Simulation Control</h3>
                    <div class="simulation-controls" style="display: flex; justify-content: space-between; gap: 10px;">
                        <button id="start-simulation" style="flex-grow: 1; padding: 0.75rem; background: var(--success-color, #27ae60); color: white; border: none; border-radius: 0.5rem; cursor: pointer; font-size: 1rem;">Start</button>
                        <button id="stop-simulation" style="flex-grow: 1; padding: 0.75rem; background: var(--danger-color, #e74c3c); color: white; border: none; border-radius: 0.5rem; cursor: pointer; font-size: 1rem;">Stop</button>
                        <button id="reset-simulation" style="flex-grow: 1; padding: 0.75rem; background: var(--warning-color, #f39c12); color: white; border: none; border-radius: 0.5rem; cursor: pointer; font-size: 1rem;">Reset</button>
                    </div>
                </div>
            </div>

            <!-- Charts Container -->
            <div class="charts-container">
                <div class="chart-wrapper">
                    <div class="chart-title">Voltage Response</div>
                    <canvas id="voltage-chart" class="chart-canvas"></canvas>
                </div>
                <div class="chart-wrapper">
                    <div class="chart-title">Reactive Power Response</div>
                    <canvas id="reactive-chart" class="chart-canvas"></canvas>
                </div>
            </div>

            <!-- Status Panel -->
            <div class="status-panel">
                <h3 style="color: var(--primary-color); margin-bottom: 1rem;">System Status</h3>
                <div class="status-item">
                    <span class="status-label">
                        <span id="status-indicator" class="status-indicator stopped"></span>
                        Simulation
                    </span>
                    <span id="simulation-status" class="status-value">Stopped</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Current Time</span>
                    <span id="current-time" class="status-value">0.00 s</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Iterations</span>
                    <span id="iteration-count" class="status-value">0</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Power Flow</span>
                    <span id="power-flow-status" class="status-value">Converged</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Voltage (Bus 2)</span>
                    <span id="bus-voltage" class="status-value">1.000 pu</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Reactive Power</span>
                    <span id="reactive-power" class="status-value">0.000 pu</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Error Display -->
    <div id="error-display"></div>

    <!-- External Dependencies -->
    <script src="https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <!-- Embedded Python Code -->
    <script type="text/python" id="embedded-newton-raphson">
import numpy as np
import math as m

def GenericNewtonRaphson(Ybus_matrix, Vreg_mag, Sgen, 
                        Sload=None, Sload_const_I=None, Sload_const_Y=None,
                        Qgen_min=None, Qgen_max=None, Qgen_cap=None, 
                        initial_V=None, Final_Output=False, Verbose_Output=False):
    """Generic Newton-Raphson Power Flow solver"""
    
    # Slack bus (known voltage, fixed angle of 0) must be bus 1
    num_buses = len(Ybus_matrix)
    
    # Input validation
    if len(Ybus_matrix[0]) != num_buses:
        raise ValueError("Ybus_matrix must be square")
        
    if len(Vreg_mag) != num_buses:
        raise ValueError("Vreg_mag size mismatch")
    
    if Sload is None:
        Sload = [complex() for x in range(num_buses)]
    
    if len(Sgen) != num_buses or len(Sload) != num_buses:
        raise ValueError("Sgen/Sload size mismatch")
    
    # Additional validation for optional parameters
    for param in [Sload_const_I, Sload_const_Y, Qgen_max, Qgen_min, Qgen_cap]:
        if param is not None and len(param) != num_buses:
            raise ValueError("Optional parameter size mismatch")
    
    # Solver parameters
    TOLERANCE = 1.0e-9
    MAX_ITERATIONS = 200
    
    # Determine which buses have regulated voltage
    Vreg_declared = [Vreg_mag[i] is not None for i in range(num_buses)]
    
    # Convert Ybus to magnitude and angle arrays for faster computation
    Ybus_mag = [[abs(Ybus_matrix[i][j]) for j in range(num_buses)] for i in range(num_buses)]
    Ybus_ang = [[np.angle(Ybus_matrix[i][j], deg=False) for j in range(num_buses)] for i in range(num_buses)]
    
    # Initialize voltage vector
    if initial_V is None:
        V = [complex(real=Vreg_mag[x] if Vreg_declared[x] else Vreg_mag[0], imag=0.0) 
             for x in range(num_buses)]
    else:
        V = [complex(real=initial_V[x].real if not Vreg_declared[x] else Vreg_mag[x],
                    imag=initial_V[x].imag) for x in range(num_buses)]
    
    Vmag = [abs(x) for x in V]
    Vang = [np.angle(x, deg=False) for x in V]
    S = [complex() for x in range(num_buses)]
    
    size = (num_buses - 1) * 2
    mismatch = [0.0 for x in range(size)]
    iteration = 0
    solved = False
    
    def calculate_Jacobian():
        """Calculate Jacobian matrix for Newton-Raphson iteration"""
        jacobian = [[0.0 for x in range(size)] for y in range(size)]
        
        for i in range(1, num_buses):
            for j in range(1, num_buses):
                # del P / del delta (angle)
                if i == j:
                    temp = 0.0
                    for k in range(num_buses):
                        if k != i:
                            temp += (Ybus_mag[i][k] * Vmag[k] * 
                                   m.sin(Vang[i] - Vang[k] - Ybus_ang[i][k]))
                    temp *= -Vmag[i]
                    jacobian[i - 1][j - 1] = temp
                else:
                    jacobian[i - 1][j - 1] = (Vmag[i] * Ybus_mag[i][j] * Vmag[j] * 
                                             m.sin(Vang[i] - Vang[j] - Ybus_ang[i][j]))
                
                # del P / del V (voltage magnitude)
                if i == j:
                    temp = Vmag[i] * Ybus_mag[i][j] * m.cos(Ybus_ang[i][j])
                    for k in range(num_buses):
                        temp += (Ybus_mag[i][k] * Vmag[k] * 
                               m.cos(Vang[i] - Vang[k] - Ybus_ang[i][k]))
                    jacobian[i - 1][j + num_buses - 2] = temp
                else:
                    jacobian[i - 1][j + num_buses - 2] = (Vmag[i] * Ybus_mag[i][j] * 
                                                         m.cos(Vang[i] - Vang[j] - Ybus_ang[i][j]))
                
                # del Q / del delta (angle)
                if i == j:
                    temp = 0.0
                    for k in range(num_buses):
                        if k != i:
                            temp += (Ybus_mag[i][k] * Vmag[k] * 
                                   m.cos(Vang[i] - Vang[k] - Ybus_ang[i][k]))
                    temp *= Vmag[i]
                    jacobian[i + num_buses - 2][j - 1] = temp
                else:
                    jacobian[i + num_buses - 2][j - 1] = (-Vmag[i] * Ybus_mag[i][j] * Vmag[j] * 
                                                         m.cos(Vang[i] - Vang[j] - Ybus_ang[i][j]))
                
                # del Q / del V (voltage magnitude)
                if i == j:
                    temp = -Vmag[i] * Ybus_mag[i][j] * m.sin(Ybus_ang[i][j])
                    for k in range(num_buses):
                        temp += (Ybus_mag[i][k] * Vmag[k] * 
                               m.sin(Vang[i] - Vang[k] - Ybus_ang[i][k]))
                    jacobian[i + num_buses - 2][j + num_buses - 2] = temp
                else:
                    jacobian[i + num_buses - 2][j + num_buses - 2] = (Vmag[i] * Ybus_mag[i][j] * 
                                                                     m.sin(Vang[i] - Vang[j] - Ybus_ang[i][j]))
        
        return jacobian
    
    # Main Newton-Raphson iteration loop
    while True:
        jacobian = calculate_Jacobian()
        
        # Update voltage phasors
        for i in range(1, num_buses):
            V[i] = complex(real=Vmag[i] * m.cos(Vang[i]),
                          imag=Vmag[i] * m.sin(Vang[i]))
        
        # Calculate currents and power
        I = np.matmul(Ybus_matrix, V)
        S = [V[i] * np.conjugate(I[i]) for i in range(num_buses)]
        
        # Determine voltage regulation status
        Vregulating = [False for x in range(num_buses)]
        
        for i in range(1, num_buses):
            if Vreg_declared[i]:
                under = False
                over = False
                
                # Check reactive power limits
                if Qgen_min is not None and Qgen_min[i] is not None:
                    if (S[i].imag + Sload[i].imag) <= Qgen_min[i] or Vmag[i] > Vreg_mag[i]:
                        under = True
                        Sgen[i] = complex(real=Sgen[i].real, imag=Qgen_min[i])
                
                if Qgen_max is not None and Qgen_max[i] is not None:
                    if (S[i].imag + Sload[i].imag) >= Qgen_max[i] or Vmag[i] < Vreg_mag[i]:
                        over = True
                        Sgen[i] = complex(real=Sgen[i].real, imag=Qgen_max[i])
                
                Vregulating[i] = (not under) and (not over)
            
            # Calculate net power injection
            Snet = Sgen[i] - Sload[i]
            
            # Apply constant current loads
            if Sload_const_I is not None and Sload_const_I[i] is not None:
                Snet -= (Vmag[i] * Sload_const_I[i])
            
            # Apply constant admittance loads
            if Sload_const_Y is not None and Sload_const_Y[i] is not None:
                Snet -= (m.pow(Vmag[i], 2) * Sload_const_Y[i])
            
            # Calculate power mismatch
            Serr = Snet - S[i]
            
            # Set up mismatch vector
            mismatch[i - 1] = Serr.real
            
            if Vregulating[i]:
                mismatch[i + num_buses - 2] = 0.0
            else:
                mismatch[i + num_buses - 2] = Serr.imag
        
        # Solve for corrections
        try:
            del_val = np.matmul(np.linalg.inv(jacobian), mismatch)
        except np.linalg.LinAlgError:
            break
        
        # Apply corrections
        for i in range(1, num_buses):
            Vang[i] += del_val[i - 1]
            
            if Vreg_declared[i]:
                if Vregulating[i]:
                    Vmag[i] = Vreg_mag[i]
                else:
                    Vmag[i] += del_val[i + num_buses - 2]
            else:
                Vmag[i] += del_val[i + num_buses - 2]
        
        iteration += 1
        
        # Check for convergence or maximum iterations
        if len(del_val) > 0:
            max_mismatch = max(np.max(del_val), -np.min(del_val))
        else:
            max_mismatch = float('inf')
        
        if iteration >= MAX_ITERATIONS:
            break
        elif max_mismatch <= TOLERANCE:
            solved = True
            break
    
    # Final voltage calculation
    for i in range(1, num_buses):
        V[i] = complex(real=Vmag[i] * m.cos(Vang[i]),
                      imag=Vmag[i] * m.sin(Vang[i]))
    
    # Final power calculation
    I = np.matmul(Ybus_matrix, V)
    S = [V[i] * np.conjugate(I[i]) for i in range(num_buses)]
    
    return [V, S, solved]
    </script>

    <script type="text/python" id="embedded-voltage-control">
import numpy as np
import random

class SimulationState:
    def __init__(self):
        self.DELT = 0.05  # 50ms time step
        self.SYS_XE = 0.05  # System reactance, pu
        self.TQ_PLANT = 0.25  # Plant time constant, seconds
        self.VCTRL_KP = 10.0  # Voltage controller proportional gain
        self.VCTRL_KI = 50.0  # Voltage controller integral gain
        self.NOISE = 0.002  # Voltage noise level, pu
        
        self.VINIT = 1.0  # Initial voltage magnitude, pu
        self.PINIT = 0.8  # Active power setpoint, pu
        self.QINIT = 0.0  # Initial reactive power, pu
        
        self.TQ_STORE = 0.0  # Plant integrator state
        self.KI_STORE = self.QINIT  # Voltage controller integrator state
        
        self.IINIT = np.conjugate(complex(self.PINIT, self.QINIT)) / self.VINIT
        self.VSYS = abs(self.VINIT - self.IINIT * complex(0, self.SYS_XE))
        
        self.max_data_points = 200  # 10 seconds at 50ms intervals
        self.time_vals = []
        self.voltage_vals = []
        self.voltage_ref_vals = []
        self.reactive_vals = []
        self.reactive_ref_vals = []
        
        self.initialize_data()
        self.setup_ybus_matrix()
        self.current_time = 0.0
        self.iteration_count = 0
    
    def initialize_data(self):
        start_time = -2 * self.DELT
        self.time_vals = [start_time, start_time + self.DELT]
        self.voltage_vals = [1.0, 1.0]
        self.voltage_ref_vals = [1.0, 1.0]
        self.reactive_vals = [0.0, 0.0]
        self.reactive_ref_vals = [0.0, 0.0]
    
    def setup_ybus_matrix(self):
        num_buses = 2
        self.Ybus_matrix = [[complex() for c in range(num_buses)] for r in range(num_buses)]
        Sys_Z = complex(0.0, self.SYS_XE)
        Yext = 1.0 / Sys_Z
        self.Ybus_matrix[0][0] = Yext
        self.Ybus_matrix[0][1] = -Yext
        self.Ybus_matrix[1][0] = -Yext
        self.Ybus_matrix[1][1] = Yext
    
    def update_parameters(self, param_dict):
        print(f"Python: Updating parameters: {param_dict}")
        updated_params = []
        if 'simulation_interval' in param_dict:
            old_val = self.DELT * 1000.0
            self.DELT = param_dict['simulation_interval'] / 1000.0
            # Recalculate max_data_points to maintain a 10-second window
            self.max_data_points = int(10.0 / self.DELT)
            print(f"Updated DELT: {old_val} -> {self.DELT * 1000.0} ms, new max_data_points: {self.max_data_points}")
            updated_params.append('simulation_interval')
        if 'noise_level' in param_dict:
            old_val = self.NOISE
            self.NOISE = param_dict['noise_level']
            print(f"Updated NOISE: {old_val} -> {self.NOISE}")
            updated_params.append('noise_level')
        if 'system_reactance' in param_dict:
            old_val = self.SYS_XE
            self.SYS_XE = param_dict['system_reactance']
            self.setup_ybus_matrix()
            print(f"Updated SYS_XE: {old_val} -> {self.SYS_XE}")
            updated_params.append('system_reactance')
        if 'plant_time_constant' in param_dict:
            old_val = self.TQ_PLANT
            self.TQ_PLANT = param_dict['plant_time_constant']
            print(f"Updated TQ_PLANT: {old_val} -> {self.TQ_PLANT}")
            updated_params.append('plant_time_constant')
        if 'voltage_kp' in param_dict:
            old_val = self.VCTRL_KP
            self.VCTRL_KP = param_dict['voltage_kp']
            print(f"Updated VCTRL_KP: {old_val} -> {self.VCTRL_KP}")
            updated_params.append('voltage_kp')
        if 'voltage_ki' in param_dict:
            old_val = self.VCTRL_KI
            self.VCTRL_KI = param_dict['voltage_ki']
            print(f"Updated VCTRL_KI: {old_val} -> {self.VCTRL_KI}")
            updated_params.append('voltage_ki')
        print(f"Python: Updated parameters: {updated_params}")
        return updated_params
    
    def maintain_rolling_window(self):
        while len(self.time_vals) > self.max_data_points:
            self.time_vals.pop(0)
            self.voltage_vals.pop(0)
            self.voltage_ref_vals.pop(0)
            self.reactive_vals.pop(0)
            self.reactive_ref_vals.pop(0)
        
        current_time = max(self.time_vals) if self.time_vals else 0
        while (self.time_vals and 
               len(self.time_vals) > 2 and 
               self.time_vals[0] < current_time - 10.0):
            self.time_vals.pop(0)
            self.voltage_vals.pop(0)
            self.voltage_ref_vals.pop(0)
            self.reactive_vals.pop(0)
            self.reactive_ref_vals.pop(0)
    
    def get_current_data(self):
        return {
            'time_values': self.time_vals.copy(),
            'voltage_reference': self.voltage_ref_vals.copy(),
            'voltage_actual': self.voltage_vals.copy(),
            'reactive_reference': self.reactive_ref_vals.copy(),
            'reactive_actual': self.reactive_vals.copy(),
            'current_time': self.current_time,
            'iteration_count': self.iteration_count,
            'converged': True
        }
    
    def reset_simulation(self):
        self.TQ_STORE = 0.0
        self.KI_STORE = self.QINIT
        self.current_time = 0.0  # Ensure exact zero initialization
        self.iteration_count = 0
        self.initialize_data()

try:
    sim_state = SimulationState()
    print("Python simulation state initialized successfully.")
except Exception as e:
    print(f"Error initializing Python simulation state: {e}")
    # Re-raise the exception to ensure the failure is propagated
    raise

def simulate_step(voltage_reference):
    global sim_state
    
    try:
        sim_state.current_time += sim_state.DELT
        # Round time to prevent floating point precision issues
        sim_state.current_time = round(sim_state.current_time, 2)
        sim_state.time_vals.append(sim_state.current_time)
        sim_state.voltage_ref_vals.append(float(voltage_reference))
        
        if len(sim_state.voltage_vals) > 0:
            error = voltage_reference - sim_state.voltage_vals[-1]
        else:
            error = 0.0
        
        DSTATE = error * sim_state.VCTRL_KI
        sim_state.KI_STORE += DSTATE * sim_state.DELT
        
        Qcmd = (error * sim_state.VCTRL_KP + 
                sim_state.KI_STORE + 
                sim_state.DELT * DSTATE / 2.0)
        
        sim_state.reactive_ref_vals.append(Qcmd)
        
        if len(sim_state.reactive_vals) > 0:
            q_last = sim_state.reactive_vals[-1]
        else:
            q_last = sim_state.QINIT
        
        q_err = Qcmd - q_last
        DSTATE = q_err / sim_state.TQ_PLANT
        sim_state.TQ_STORE += DSTATE * sim_state.DELT
        q_new = sim_state.TQ_STORE + sim_state.DELT * DSTATE / 2.0
        sim_state.reactive_vals.append(q_new)
        
        Vsys = sim_state.VSYS + (random.random() - 0.5) * 2.0 * sim_state.NOISE
        
        try:
            Vout, Sout, solved = GenericNewtonRaphson(
                Ybus_matrix=sim_state.Ybus_matrix,
                Vreg_mag=[complex(Vsys), None],
                Sgen=[None, complex(sim_state.PINIT, q_new)],
                Verbose_Output=False
            )
            v_new = abs(Vout[1])
            sim_state.voltage_vals.append(v_new)
            convergence_status = solved
            
        except Exception as e:
            if len(sim_state.voltage_vals) > 0:
                sim_state.voltage_vals.append(sim_state.voltage_vals[-1])
            else:
                sim_state.voltage_vals.append(sim_state.VINIT)
            convergence_status = False
        
        sim_state.maintain_rolling_window()
        sim_state.iteration_count += 1
        
        return {
            'time': sim_state.current_time,
            'voltage_reference': voltage_reference,
            'voltage_actual': sim_state.voltage_vals[-1],
            'reactive_reference': Qcmd,
            'reactive_actual': q_new,
            'converged': convergence_status,
            'iteration': sim_state.iteration_count,
            'data_arrays': sim_state.get_current_data()
        }
        
    except Exception as e:
        return {
            'time': sim_state.current_time,
            'voltage_reference': voltage_reference,
            'voltage_actual': 1.0,
            'reactive_reference': 0.0,
            'reactive_actual': 0.0,
            'converged': False,
            'error': str(e),
            'iteration': sim_state.iteration_count,
            'data_arrays': sim_state.get_current_data()
        }

def update_simulation_parameters(param_dict):
    global sim_state
    return sim_state.update_parameters(param_dict)

def get_simulation_data():
    global sim_state
    return sim_state.get_current_data()

def reset_simulation():
    global sim_state
    sim_state.reset_simulation()
    return True

def get_simulation_config():
    """Get current simulation configuration"""
    global sim_state
    
    return {
        'simulation_interval': sim_state.DELT * 1000.0,  # Convert to milliseconds
        'noise_level': sim_state.NOISE,
        'system_reactance': sim_state.SYS_XE,
        'plant_time_constant': sim_state.TQ_PLANT,
        'voltage_kp': sim_state.VCTRL_KP,
        'voltage_ki': sim_state.VCTRL_KI,
        'active_power': sim_state.PINIT,
        'system_voltage': sim_state.VSYS,
        'max_data_points': sim_state.max_data_points
    }

def validate_simulation_health():
    """Check simulation health and provide diagnostics"""
    global sim_state
    
    health_status = {
        'status': 'healthy',
        'warnings': [],
        'data_points': len(sim_state.time_vals),
        'current_time': sim_state.current_time,
        'iteration_count': sim_state.iteration_count
    }
    
    return health_status
    </script>

    <!-- Main JavaScript Application -->
    <script src="app.js"></script>
</body>
</html>